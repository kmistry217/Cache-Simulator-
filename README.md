# Cache-Simulator-

Overview
The goal of this assignment is to provide you a better understanding of caches. You
are required to write a cache simulator using the C programming language. The
programs have to run on iLab machines and should be tested with the autograder.
We are providing real program memory traces as input to your cache simulator.
The format and structure of the memory traces are described below.

Memory Access Traces
The input to the cache simulator is a memory access trace, which we have
generated by executing real programs. The trace contains memory addresses
accessed during program execution. Your cache simulator will have to use these
addresses to determine if the access is a hit, miss, and the actions to perform.

The memory trace file consists of multiple lines. Each line of the trace file
corresponds to a memory accesses performed by the program. Each line consists of
multiple columns, which are space separated. The first column reports the PC
(program counter) when this particular memory access occurred, followed by a
colon(:). Second column lists whether the memory access is a read (R) or a write
(W) operation. And the last column reports the actual 48-bit memory address that
has been accessed by the program. In this assignment, you only need to consider
the second and the third columns (i.e. you don’t really need to know the PCs). The
last line of the trace file will be the string #eof

Here is a sample trace file:
0x804ae19: R 0x9cb3d40
0x804ae19: W 0x9cb3d40
0x804ae1c: R 0x9cb3d44
0x804ae1c: W 0x9cb3d44
0x804ae10: R 0xbf8ef498
#eof 

Cache Simulator (100 points)
You will implement a cache simulator to evaluate different configurations of
caches. It should be able to run with different traces files. The followings are the
requirements for your cache simulator:

1. Simulate only one level cache: L1
2. The cache size, associativity, and block size are input parameters. Cache size
and block size are specified in bytes.
3. Replacement algorithm: First In First Out (FIFO). When a block needs to be
replaced, the cache evicts the block that was accessed first. It does not take into
account whether the block is frequently or recently accessed..
4. It’s a write through cache.

Running your Cache Simulator
 You have to name your cache simulator first. Your program should support the
following usage interface:
./first <cache size> <associativity><cache policy> <block size> <trace file>
  
where:

 A) < cachesize > is the total size of the cache in bytes. This number should be a
power of 2.
 B) < associativity > is one of:
– direct - simulate a direct mapped cache.
– assoc - simulate a fully associative cache.
 – assoc:n - simulate an n − way associative cache. n will be a power of 2.
C) <cache policy> Here is valid cache policy is fifo.
D) < blocksize > is a power of 2 integer that specifies the size of the cache block in
bytes.
E) < tracefile > is the name of the trace file.
  
Cache Prefetcher:
Prefetching is a common technique to increase the spatial locality of the caches
beyond the cache line. The idea of prefetching is to bring the data into the cache
before it is needed (accessed). In a normal cache, you bring a block of data into the
cache whenever you experience a cache-miss. Now, we want you to explore a
different type of cache that prefetches not only brings the block corresponding to
the access but also prefetches one adjacent block, which will result in one extra
memory read. An adjacent block to a memory address A is defined as follows: it is
the block corresponding to the memory address A+ block_size.

For example, if a memory address 0x40 misses in the cache and the block size is 4
bytes, then the prefetcher would bring the block corresponding to 0x40 + 4 into the
cache.

The prefetcher is activated only on misses and it is not active on a cache hit. If the
prefetched block is already in the cache, it does not read the block from memory.
With respect to cache replacement policies, if the prefetched block hits in the
cache, the line replacement policy status should not be updated. Otherwise, it
is treated similar to a block that missed the cache.

Sample Run
Your program should print out the number of memory reads (per cache block),
memory writes (per cache block), cache hits, and cache misses for normal cache
and the cache with prefetcher. You should follow the exact same format shown
below (pay attention to case sensitivity of the letters), otherwise, the autograder
can not grade your program properly.

$./first 32 assoc:2 fifo 4 trace2.txt
no-prefetch
Memory reads: 3499
Memory writes: 2861
Cache hits: 6501
Cache misses: 3499
with-prefetch
Memory reads: 3521
Memory writes: 2861
Cache hits: 8124
Cache misses: 1876

In this example above, we are simulating 2-way set associate cache of size 32
bytes. Each cache block is 4 bytes. The trace file name is “trace2.txt”.
As you can see, the simulator should simulate both catch types with the prefetcher
and without the prefetcher in a single run and display the results for both. 
